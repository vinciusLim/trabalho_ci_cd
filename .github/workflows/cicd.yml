name: CI/CD - Flask + Docker + EC2

on:
  push:
    branches: ["main"] # O pipeline serÃ¡ disparado a cada push no branch 'main'

env:
  # Define o caminho completo da imagem no Docker Hub
  # Substitua 'seu-nome-do-repo' pelo nome do seu projeto (ex: trabalho-devops)
  DOCKER_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/trabalho_ci_cd

jobs:
  # -------------------------------
  # JOB 1: CI (Testes)
  # -------------------------------
  ci:
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ“¥ Checkout do CÃ³digo
        uses: actions/checkout@v4

      - name: ðŸ Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Instalar DependÃªncias
        # Assume que requirements.txt estÃ¡ na raiz ou em ./app/
        working-directory: app
        run: pip install -r requirements.txt

      - name: ðŸ› ï¸ Adicionar Projeto ao PYTHONPATH
        run: echo "PYTHONPATH=$(pwd)" >> $GITHUB_ENV # Adiciona a raiz do repo ao path
      
      - name: ðŸ§ª Rodar Testes UnitÃ¡rios
        run: pytest # Agora ele encontrarÃ¡ o mÃ³dulo 'app'

  # -------------------------------
  # JOB 2: Build e Push da Imagem
  # -------------------------------
  build-and-push:
    needs: ci # SÃ³ executa se os testes passarem
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ“¥ Checkout do CÃ³digo
        uses: actions/checkout@v4
      
      # Tagging: Usa os 7 primeiros caracteres do SHA do commit para garantir uma tag Ãºnica
      - name: ðŸ·ï¸ Definir Tag da Imagem
        id: vars
        run: echo "TAG=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT
        
      - name: ðŸ” Login no DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: âš™ï¸ Build e Push da Imagem
        uses: docker/build-push-action@v5
        with:
          context: . # Assume que o Dockerfile estÃ¡ na raiz
          file: ./app/Dockerfile
          push: true
          # Publica com a tag 'latest' e a tag baseada no SHA
          tags: |
            ${{ env.DOCKER_IMAGE }}:latest
            ${{ env.DOCKER_IMAGE }}:${{ steps.vars.outputs.TAG }}

    outputs:
      image_tag: ${{ steps.vars.outputs.TAG }} # Passa o valor do SHA para o prÃ³ximo job

  # -------------------------------
  # JOB 3: Provisionar Infraestrutura (IaC) - NOVO JOB
  # -------------------------------
  provision-infra:
    name: ðŸ—ï¸ Provisionar Infraestrutura
    runs-on: ubuntu-latest
    needs: [build-and-push]
    # Define o output IP que serÃ¡ usado no deploy
    outputs:
      server_ip: ${{ steps.ip_capture.outputs.ip }} 

    steps:
      - name: ðŸ“¥ Checkout do CÃ³digo
        uses: actions/checkout@v4

      - name: ðŸ› ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: ðŸ”‘ Configurar Credenciais AWS
        # NecessÃ¡rio para autenticar no Provider AWS e no Backend S3
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1 # Deve ser a mesma regiÃ£o do main.tf

      - name: âš™ï¸ Terraform Init e Apply
        id: apply
        run: |
          cd terraform/
          terraform init -upgrade   
          terraform apply -auto-approve

      - name: ðŸ” Capturar IP PÃºblico do Output
        id: ip_capture
        run: |
          cd terraform/
          # Captura o valor do output 'public_ip'
          IP_PUBLICO=$(terraform output -raw public_ip)
          echo "ip=$IP_PUBLICO" >> $GITHUB_OUTPUT

  # -----------------------------------------------------
  # JOB 4: CD (Deploy via SSH) - IP DINÃ‚MICO
  # -----------------------------------------------------
  deploy:
    name: ðŸš€ Deploy na EC2 via SSH
    needs: [build-and-push, provision-infra]
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ“¥ Checkout do CÃ³digo
        uses: actions/checkout@v4
        
      - name: ðŸš€ Executar Deploy
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ needs.provision-infra.outputs.server_ip }}
          username: ec2-user
          key: ${{ secrets.SSH_KEY }}
          
          script: |
            # --- VariÃ¡veis ---
            export IMAGE_TAG=${{ needs.build-and-push.outputs.image_tag }}
            export DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
            
            # --- Deploy ---
            if [ ! -d "trabalho_ci_cd" ]; then
                git clone https://github.com/${{ github.repository_owner }}/trabalho_ci_cd.git
                
                # CORREÃ‡ÃƒO ALTERNATIVA: Usando printf (mais robusto)
                printf "MYSQL_ROOT_PASSWORD=%s\nMYSQL_DATABASE=%s\nMYSQL_USER=%s\nMYSQL_PASSWORD=%s\n" \
                  "${{ secrets.MYSQL_ROOT_PASSWORD }}" \
                  "${{ secrets.MYSQL_DATABASE }}" \
                  "${{ secrets.MYSQL_USER }}" \
                  "${{ secrets.MYSQL_PASSWORD }}" \
                  "${DOCKERHUB_USERNAME}" \
                  "${IMAGE_TAG}" > trabalho_ci_cd/.env > trabalho_ci_cd/.env
            fi
            
            # 2. NAVEGAR E ATUALIZAR
            cd trabalho_ci_cd
            git pull origin main
            
            # 3. Puxar a imagem com a tag SHA mais recente
            docker pull ${DOCKERHUB_USERNAME}/trabalho_ci_cd:$IMAGE_TAG
            
            # 4. Parar/remover o container antigo e subir o novo
            /usr/bin/docker-compose -f docker-compose.prod.yml down -v || true
            /usr/bin/docker-compose -f docker-compose.prod.yml --env-file .env up -d --force-recreate
